'use strict';

const { expect } = require('chai');
const { Transform } = require('stream');
const MetaPipe = require('./index');


describe('@class MetaPipe', function() {

  const pipeline = new MetaPipe({ objectMode: true });

  it('should passthrough the provided data', function() {
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({ foo: 'bar' });
  });

  it('should append and prepend the transformers', function() {
    const tform1 = new Transform({
      transform: (data, enc, cb) => {
        data.bar = 'baz';
        cb(null, data);
      },
      objectMode: true
    });
    const tform2 = new Transform({
      transform: (data, enc, cb) => {
        data.baz = 'foo';
        cb(null, data);
      },
      objectMode: true
    });
    pipeline.append(tform1);
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({
      foo: 'bar',
      bar: 'baz'
    });
    pipeline.prepend(tform2);
    pipeline.write({ foo: 'bar' });
    expect(pipeline.read()).to.deep.equal({
      foo: 'bar',
      bar: 'baz',
      baz: 'foo'
    });
  });

  it('should flush and end', function(done) {
    pipeline.once('end', done);
    setImmediate(() => {
      pipeline.end();
      pipeline.read();
    });
  });

  it('should bubble errors from child streams', function(done) {
    const pipeline = new MetaPipe();
    const tform3 = new Transform({
      transform: (data, enc, cb) => {
        cb(new Error('FATAL'));
      }
    });
    pipeline.append(tform3);
    pipeline.once('error', (err) => {
      expect(err.message).to.equal('FATAL');
      done();
    });
    pipeline.write('test');
  });

  it('should bubble errors from child streams', function(done) {
    const pipeline = new MetaPipe();
    const tform3 = new Transform({
      transform: (data, enc, cb) => {
        cb(new Error('FATAL'));
      }
    });
    pipeline.prepend(tform3);
    pipeline.once('error', (err) => {
      expect(err.message).to.equal('FATAL');
      done();
    });
    pipeline.write('test');
  });

  it('should tolerate errors and repipe streams', function(done) {
    const pipeline = new MetaPipe();
    const tform1 = new Transform({
      transform: (data, enc, cb) => cb(null, data)
    });
    const tform2 = new Transform({
      transform: (data, enc, cb) => cb(null, data)
    });
    const tform3 = new Transform({
      transform: (data, enc, cb) => cb(null, data)
    });
    pipeline.append(tform1);
    pipeline.append(tform2);
    pipeline.append(tform3);
    pipeline.once('data', (data) => {
      expect(data.toString()).to.equal('after error');
      done();
    }).once('error', (err) => {
      expect(err.message).to.equal('Failed');
    });
    setImmediate(() => {
      tform2.emit('error', new Error('Failed'));
      setImmediate(() => pipeline.write('after error'));
    });
  });

});
